# 原题
给定n个气球。每次你可以打破一个，打破第i个，
那么你会获得nums[left] * nums[i] * nums[right]个积分。 （nums[-1] = nums[n] = 1）求你可以获得的最大积分数

注意点：

  - 无

例子：

```
Input: [3,1,5,8]

Output: 167 

Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

# 解题思路
dp[i][j]为打破的气球为i~j之间。

我们可以想象：最后的剩下一个气球为i的时候，可以获得的分数为：nums[-1]*nums[i]*nums[n].

那么介于i,j之间的x，有： dp[i][j] = max(dp[i][j], dp[i][x – 1] + nums[i – 1] * nums[x] * nums[j + 1] + dp[x + 1][j]);

这里，为了方便代码书写，我在首尾插入了两个1，所以答案是 dp[1][n] (n为原来的长度)

可以用记忆化搜索也可以直接迭代DP,当然，记忆化搜索更好理解一点。
