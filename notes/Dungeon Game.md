# 原题
公主被困在地牢（可以理解为矩阵或者二维数组）的右下角，骑士从左上角出发去救公主。骑士拥有一定的初始血量，
如果途中他的血量少于等于0，那么营救失败。地牢中的每个格子都有一个数字，负数表示骑士收到了伤害，
正数（可能为0）表示骑士回复了一定的血量。现在规定骑士只能向右或者向下前进，求骑士的初始血量至少为多少才能救出公主。

注意点：

  - 骑士的血量没有上限规定
  - 每格地牢都有数字，包括起点和终点。

例子:

```
输入:

-2 (K)   |  -3   |    3
-5       |  -10  |    1
10       |  30   |    -5 (P)

输出: 7 (右->右->下->下)
```

# 解题思路
### 动态规划

骑士向右或者向下走，如果血量小于0就死掉了，这会使得计算变得很复杂。
如果我们从后往前看，从最后一个格子逆推回去，就会简单很多。
每个格子可以是它下方或者右方的格子逆推回来，那么要让其实的血量最少，我们则要保证逆推的每一步都处于活着的状态，
且选择活着的状态中，血量较小的那一种。假设`health[i][j]`表示点i和j的血量，
`dungeon[i][j]`表示走到i和j要扣除的血量。如果从下方逆推回上面，
则血量为`health[i][j] = health[i + 1][j] - dungeon[i][j]`，
但要考虑，如果该格子如果扣血扣太多的，则这样相减血量会成为负数，说明骑士就已经死了，
这样的话我们要保证扣完血后骑士还活着，则该点的血量就应该为1。
所以其实是`health[i][j] = Math.max(health[i + 1][j] - dungeon[i][j], 1)`。
同理，如果从右边逆推回来，则`health[i][j] = Math.max(health[i][j] - dungeon[i][j + 1], 1)`。
最后，我们在这两个逆推的值中，取较小的那个就行了。

### 注意
  - 由于最下面一行和最右面一列比较特殊，只有一种逆推方法，所以我们要先单独处理一下。
  - 最右下角那个节点没有待逆推的节点，所以我们假设其逆推节点的血量为1。

### 复杂度
时间 O(N) 空间 O(N) 递归栈
