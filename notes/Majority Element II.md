# 原题
找出一个数组中出现次数超过`⌊ n/3 ⌋`次的所有数字。


注意点：

  - The algorithm should run in linear time and in O(1) space.

例子：

```
Example 1:

Input: [3,2,3]
Output: [3]

Example 2:

Input: [1,1,1,3,3,2,2,2]
Output: [1,2]

```

# 解题思路
### 摩尔投票法 Moore Voting
题目要求的是线性时间和常量的空间，首先我们肯定知道数组中出现次数超过⌊ n/3 ⌋次的最多有两个！
因为如果3个的话，这三个数字的总次数 > 3×⌊ n/3 ⌋ = n，不可能的。
所以我们对这个题的做法同样使用摩尔投票法，先使用两个变量分别保存次数最多和次多的就可以了。
然后我们还需要再过一遍数组，判断次数最多和次多的是不是超过了⌊ n/3 ⌋次，把超过的数字返回就行了。

注意：

  - 在第一个for循环中，必须先判断是不是已经和已有的相等，如果不满足的情况下才能判断是不是次数为0。比如题目中给的例子[1,1,1,3,3,2,2,2]，
  如果先判断cm和cn的次数是不是0，那么会把m和n分别都设置成了1。而我们的目的是m和n分别代表两个不同的数字，所以应该先做是不是和已有的数字相等的判断。
  - 统计次数的时候需要用if 和else if，不能两个if。这个是因为我们把m和n都初始化成了0，对于[0,0,0]这个测试用例，如果两个if会导致结果是[0,0]。
  

记变量n1, n2为候选众数； c1, c2为它们对应的出现次数

遍历数组，记当前数字为num

若num与n1或n2相同，则将其对应的出现次数加1

否则，若c1或c2为0，则将其置为1，对应的候选众数置为num

否则，将c1与c2分别减1

最后，再统计一次候选众数在数组中出现的次数，若满足要求，则返回之。

时间复杂度是O(N)，空间复杂度是O(1)。
