# 原题
把一个集合的单词按照每行maxWidth个字符存放，不足的在单词间添加空格，每行要两端对齐(即两端都要是单词)，
如果空格不能均匀分布在所有间隔中，那么左边的空格要多于右边的空格，最后一行靠左对齐，每个单词间一个空格。

注意点：

  - 单词的顺序不能发生改变
  - 中间行也可能出现只有一个单词，这时要靠左对齐
  - 每行要尽可能多的容纳单词

例子：

输入: 

words = ["This", "is", "an", "example", "of", "text", "justification."]

maxWidth = 16

输出:

[
   "This    is    an",
   "example  of text",
   "justification.  "
]

# 解题思路
这道题属于纯粹的字符串操作，要把一串单词安排成多行限定长度的字符串。
主要难点在于空格的安排，首先每个单词之间必须有空格隔开，而当当前行放不下更多的单词并且字符又不能填满长度maxWidth时，
我们要把空格均匀的填充在单词之间。如果剩余的空格量刚好是间隔倍数那么就均匀分配即可，
否则还必须把多的一个空格放到前面的间隔里面。实现中我们维护一个count计数记录当前长度，
超过之后我们计算共同的空格量以及多出一个的空格量，然后将当行字符串构造出来。
最后一个细节就是最后一行不需要均匀分配空格，句尾留空就可以，所以要单独处理一下。
时间上我们需要扫描单词一遍，然后在找到行尾的时候在扫描一遍当前行的单词，
不过总体每个单词不会被访问超过两遍，所以总体时间复杂度是O(n)。
而空间复杂度则是结果的大小（跟单词数量和长度有关，不能准确定义，如果知道最 后行数r，则是O(r*L)）。
