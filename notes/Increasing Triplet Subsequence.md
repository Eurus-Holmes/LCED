# 原题
给定一个无序数组，判断其中是否存在一个长度为3的递增子序列。

形式上，函数应当：

```
如果存在这样的i, j, k（0 ≤ i < j < k ≤ n-1），使得arr[i] < arr[j] < arr[k]，返回true，否则返回false。
```

注意点：

  - 满足O(n)时间复杂度和O(1)空间复杂度

例子：

```
Example 1:

Input: [1,2,3,4,5]
Output: true

Example 2:

Input: [5,4,3,2,1]
Output: false
```

# 解题思路

维护变量a, b，用来记录数组中大小递增的前2个元素。

更确切的说：a是当前的最小元素；b是位于a之后，大于a并且距离a最近的元素。

```
初始令a = b = None

遍历数组nums，记当前元素为n

  若a为空或者a >= n，则令a = n；

  否则，若b为空或者b >= n，则令b = n；

  否则，返回true

遍历结束时，返回false。
```

既然要求我们从前到后遍历，那么在遍历的时候保存已经看到的最小值和次小值，
然后再发现比这两个值大的的第3小的值存在的时候，那么就说明有长度为3的递增的子序列了。

当然，对于这种情况：

```
4  5  1  2  6 
```

长度为3递增子序列有两种，但是由于我们保存的是最小的优先，所以最后的结果求得的是1 2 6这组。

整体的思想其实是很灵活的，保存的是遍历时见到的最小和次小，因此千万不要使用一成不变的min和max函数。











