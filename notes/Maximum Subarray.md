# 原题
求一个数组中和最大的子数组。

注意点：

  - 需要考虑负数的情况

例子：

输入: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

输出: 6(数组[4, -1, 2, 1]的和)

# 解题思路

## 思路1
题意是求数组中子数组的最大和，这种最优问题一般第一时间想到的就是动态规划，
我们可以这样想，当部分序列和大于零的话就一直加下一个元素即可，
并和当前最大值进行比较，如果出现部分序列小于零的情况，
那肯定就是从当前元素算起。其转移方程就是 `dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);`，
由于我们不需要保留 dp 状态，故可以优化空间复杂度为 1，即 `dp = nums[i] + (dp > 0 ? dp : 0);`。

## 思路2
题目也给了我们另一种思路，就是分治，
所谓分治就是把问题分割成更小的，最后再合并即可，
我们把 nums 一分为二先，那么就有两种情况，一种最大序列包括中间的值，
一种就是不包括，也就是在左边或者右边；当最大序列在中间的时候那我们就把它两侧的最大和算出即可；
当在两侧的话就继续分治即可。

