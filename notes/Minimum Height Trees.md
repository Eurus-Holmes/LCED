# 原题
找出以哪些节点为根节点的时候，构建出来的整棵树的高度是最低的。

注意点：

  - 无

例子：

```
Example 1 :

Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3 

Output: [1]

Example 2 :

Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5 

Output: [3, 4]
```

# 解题思路
### BFS
这个题给定的是个图，但是让我们构建成树，也就是说构建出来的并不是二叉树。
题目其实想考我们的是，整个图最靠近中间的节点是什么。我们使用类似与拓扑排序的BFS进行解决。

拓扑排序我们都知道，每次选择入度为0的节点进行删除。在这个题中，因为我们要找到无向图最靠近中间的节点，所以，
我们先使用一个字典保存每个节点的所有相邻节点set。每次把所有只有一个邻接的节点（叶子节点，类似于入度为0，但是这是个无向图，入度等于出度）都放入队列，
然后遍历队列中的节点u，把和每个节点u相邻的节点v的set删去u，所以这一步操作得到的是去除了叶子节点的新一轮的图。
所以我们需要再次进行选择只有一个邻接节点的叶子节点，然后放入队列中，再次操作。最后结束的标准是，整个图只留下了1个或者两个元素。
为什么不能是3个呢？因为题目第一句话说了给出的图是具有树的特性的，所以一定没有环存在。

这个题整体的思路就是把所有的叶子节点放入队列中，然后同时向中间遍历，这样最后剩下来的就是整棵树中间的元素。

时间复杂度是O(V)，空间复杂度是O(E + V).

